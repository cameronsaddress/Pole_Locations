import asyncio
import csv
import logging
import os
from contextlib import asynccontextmanager
from pathlib import Path
from typing import List, Optional

from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Constants
TRAIN_DIR = Path("/models/train_runs/yolov8l_custom2")
RESULTS_FILE = TRAIN_DIR / "results.csv"

# Mock Data Config
MOCK_ASSET_COUNT = 1250
HARRISBURG_CENTER = (40.26, -76.88)

class Asset(BaseModel):
    id: str
    lat: float
    lng: float
    status: str
    confidence: float
    detected_at: str

class TrainingStats(BaseModel):
    epoch: int
    total_epochs: int = 20
    box_loss: float
    map50: float
    status: str

class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def broadcast(self, message: dict):
        for connection in self.active_connections:
            await connection.send_json(message)

manager = ConnectionManager()

def get_latest_stats() -> TrainingStats:
    """Parses results.csv to get the latest training metrics."""
    if not RESULTS_FILE.exists():
        return TrainingStats(epoch=0, box_loss=0.0, map50=0.0, status="Idle")
    
    try:
        with open(RESULTS_FILE, "r") as f:
            lines = f.readlines()
            if len(lines) < 2:
                return TrainingStats(epoch=0, box_loss=0.0, map50=0.0, status="Initializing")
            
            # YOLO results.csv headers are usually first line
            # Last line is latest epoch
            last_line = lines[-1].strip().split(",")
            # Column mapping depends on YOLO version, typically:
            # 0: epoch, 1: train/box_loss, ... 6: metrics/mAP50(B)
            # We'll do a robust check or assumes standard indices for now:
            # epoch is usually col 0
            epoch = int(float(last_line[0].strip()))
            box_loss = float(last_line[1].strip())
            # mAP50 is often around col 6 or 7
            map50 = float(last_line[6].strip()) 
            
            return TrainingStats(
                epoch=epoch,
                box_loss=box_loss,
                map50=map50,
                status="Active"
            )
    except Exception as e:
        logger.error(f"Error parsing results.csv: {e}")
        return TrainingStats(epoch=0, box_loss=0.0, map50=0.0, status="Error")

@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("Starting PoleVision Enterprise API...")
    yield
    logger.info("Shutting down...")

app = FastAPI(
    title="PoleVision Enterprise API",
    version="2.0.0",
    lifespan=lifespan
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/health")
async def health_check():
    return {"status": "healthy", "version": "2.0.0"}

@app.get("/api/v2/stats/training", response_model=TrainingStats)
async def get_training_stats():
    return get_latest_stats()

from datetime import datetime

def load_real_assets():
    """
    Load verified assets from the CSV generated by the pilot pipeline.
    """
    assets = []
    csv_path = Path("/data/processed/verified_poles_multi_source.csv")
    
    # Fallback if running locally vs in docker (and data is in ./data)
    if not csv_path.exists():
        csv_path = Path("data/processed/verified_poles_multi_source.csv")

    if not csv_path.exists():
        print(f"WARNING: Real data file not found at {csv_path}. Returning empty list.")
        return []

    try:
        with open(csv_path, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                # Map CSV status to UI status
                raw_class = row.get("classification", "unknown")
                if raw_class == "verified_good":
                    status = "Verified"
                elif raw_class == "in_question" or row.get("needs_review") == "True":
                    status = "Review"
                else:
                    status = "Missing"

                # Parse confidence and context
                try:
                    conf = float(row.get("total_confidence", 0.0))
                    road_dist = float(row.get("road_distance_m", 9999.0))
                except:
                    conf = 0.0
                    road_dist = 9999.0

                # AGGRESSIVE FILTER: Drop "In Question" / "Review" poles far from roads
                # This kills the "forest grid" hallucinations (false positives in vegetation)
                # We KEEP "Verified" poles because transmission lines often run cross-country
                if status == "Review" and road_dist > 35.0:
                    # logger.info(f"Filtered pole {row.get('pole_id')} (Dist: {road_dist}m)")
                    continue

                assets.append(Asset(
                    id=row.get("pole_id", "UNKNOWN"),
                    lat=float(row.get("lat", 0.0)),
                    lng=float(row.get("lon", 0.0)),
                    status=status,
                    confidence=conf,
                    detected_at=row.get("inspection_date") or datetime.now().isoformat()
                ))
        print(f"Loaded {len(assets)} real assets from {csv_path}")
    except Exception as e:
        print(f"Error loading assets: {e}")
        
    return assets

CACHED_ASSETS = load_real_assets()

@app.get("/api/v2/assets", response_model=List[Asset])
async def get_assets(
    min_lat: Optional[float] = None,
    max_lat: Optional[float] = None,
    min_lng: Optional[float] = None,
    max_lng: Optional[float] = None
):
    """
    Get assets, optionally filtered by a bounding box.
    """
    # If no bounds, return empty to save bandwidth/crash (or return a small sample?)
    # User asked for "only download dots that are in our view", so default to empty or very strictly limited is safer.
    if min_lat is None:
        return []

    # Filter in memory (fast enough for 176k records)
    # Whitelisted County Bounds (approximate) to prevent dots appearing outside
    # [min_lat, min_lng, max_lat, max_lng]
    COUNTY_BOUNDS = [
        [40.12, -77.05, 40.67, -76.55], # Dauphin (roughly)
        [39.71, -77.15, 40.25, -76.40], # York (Expanded)
        [40.0, -77.60, 40.35, -76.85],  # Cumberland
        [39.72, -77.47, 40.0, -77.06],  # Adams (Bordering York/Cumberland)
        [40.23, -76.65, 40.58, -76.28],  # Lebanon (Bordering Dauphin)
    ]

    def is_in_whitelist(lat, lng):
        for b in COUNTY_BOUNDS:
            if b[0] <= lat <= b[2] and b[1] <= lng <= b[3]:
                return True
        return False

    filtered = [
        a for a in CACHED_ASSETS 
        if min_lat <= a.lat <= max_lat and min_lng <= a.lng <= max_lng and is_in_whitelist(a.lat, a.lng)
    ]
    
    # Hard limit to prevent browser crash if zoomed out too far
    if len(filtered) > 5000:
        # Prioritize VERIFIED poles first, then sort by confidence
        # This prevents "grids" of low-confidence detections from crowding out real lines
        def get_priority(asset):
            if asset.status == "Verified": return 3
            if asset.status == "Review": return 2
            return 1
            
        filtered.sort(key=lambda x: (get_priority(x), x.confidence), reverse=True)
        return filtered[:5000]
        
    return filtered

@app.websocket("/ws/training")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            stats = get_latest_stats()
            await websocket.send_json(stats.model_dump())
            await asyncio.sleep(2) # Stream updates every 2s
    except WebSocketDisconnect:
        manager.disconnect(websocket)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
